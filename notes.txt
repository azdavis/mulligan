
We need to decide whether we want to use a stripped-down AST (without tokens,
without location information, and with just the strict expression information),
or if we want to use Sam's austere AST (with all of the above).

To support "stars" (which will denote "holes" in expressions of where the
computation currently is), it seems we need a new tree.

But if we don't use the austere AST, we lose the existing pretty printer.
OK, so the existing pretty printer works solely by utilizing the existing
source, meaning that we can't use the original pretty printer anyways.

Seems to be little reason NOT to just translate to something new.

to compile:
mlton -mlb-path-var 'COMPAT mlton' -default-ann 'allowOrPats true' sources.mlb

We have an issue.
The debugger is founded on the idea that the size of semantic objects (i.e.
expressions) during the course of runtime will be finite.

Now, this is clearly not true. See:
fun fact 0 = 1
  | fact n = n * fact (n - 1)
We want some kind of "delayed" evaluation where:

fact n =

fun f n = g n
and g n = f n

f n
==> g n
==> f n

IMPORTANT: The pretty printer is contextual.

This means that substitution never actually needs to happen. We know that it's
equivalent to either eagerly substitute values, or to keep them around as a
lookup table with an expression with free variables.

The problem is that substitution is hard, and you can't go back. So the pretty
printer can just take in an un-substituted expression, equipped with its
closure, and then generate the text as needed.

So we never have to actually do substitution, we can just alter the context.

constructor equivalence when shadowing exceptions or datatypes

replicating datatypes and exceptions warrants a separate thing in context for
them

users will be able to enter non-typechecking inputs if we have no type
information...

The first pass (elaboration) is supposed to be contextual, but this duplicates a
lot of annoying code, so I've decided to make it non-contextual.

This means we can't do things like put the context into the Efn, change Eidents
to Econstrs, etc, but this can be done in a later pass.



I did a naive solution to break functions.
When you say you want to break a function `f`, you just set a flag on the value
bound to the identifier `f` at that stage in the function.
Then, when that value is used for function application, the program is
appropriately halted.
This relies on the fact that every invocation of the broken function always
corresponds to that value, however. This is not the case for mutually recursive
functions.


