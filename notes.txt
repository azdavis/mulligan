
to compile:
mlton -mlb-path-var 'COMPAT mlton' -default-ann 'allowOrPats true' sources.mlb

IMPORTANT: The pretty printer is contextual.

This means that substitution never actually needs to happen. We know that it's
equivalent to either eagerly substitute values, or to keep them around as a
lookup table with an expression with free variables.

The problem is that substitution is hard, and you can't go back. So the pretty
printer can just take in an un-substituted expression, equipped with its
closure, and then generate the text as needed.

So we never have to actually do substitution, we can just alter the context.

constructor equivalence when shadowing exceptions or datatypes

replicating datatypes and exceptions warrants a separate thing in context for
them

users will be able to enter non-typechecking inputs if we have no type
information...

The first pass (elaboration) is supposed to be contextual, but this duplicates a
lot of annoying code, so I've decided to make it non-contextual.

This means we can't do things like put the context into the Efn, change Eidents
to Econstrs, etc, but this can be done in a later pass.

All function values come equipped with their own reference cell for whether or
not they have been broken. Then, upon breaking a function, that flag will be set
for every copy, including the recursive copies within the special closures for
mutually recursive functions.

This means that breaking functions persists beyond names, but are attached to
the exact function value.

KNOWN ISSUES:
- Types don't exist yet
- Constructor and exception generativity doesn't exist, matching happens only on
  the basis of names.
- Equality is not yet implemented.
- It looks like shit
- should probably stop before entering a Let body
- Sources in CM files are processed in linear order, which may not be correct.
  For full correctness, they should be processed to determine the dependency
  graph, and then an ordering selected from there.
- No support for .mlb files

