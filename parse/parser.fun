(* File generated by CM-Yacc version 2.1 *)

functor ParserFun
   (structure Streamable : STREAMABLE
    structure Arg :
       sig
          type int
          type symbol
          type directive

          val main : directive -> directive
          val num_reveal : int -> directive
          val bare_reveal : unit -> directive
          val num_prev : int -> directive
          val prev : unit -> directive
          val stop : unit -> directive
          val step : unit -> directive

          datatype terminal =
             NUM of int
           | SYMBOL of symbol
           | STEP
           | REVEAL
           | STOP
           | EQUAL
           | SET
           | PREV
           | EOF

          val error : terminal Streamable.t -> exn
       end)
   :>
   sig
      val parse : Arg.terminal Streamable.t -> Arg.directive * Arg.terminal Streamable.t
   end
=

(*

AUTOMATON LISTING
=================

State 0:

start -> . Main  / 0
0 : Directive -> . STEP  / 1
1 : Directive -> . STOP  / 1
2 : Directive -> . PREV  / 1
3 : Directive -> . PREV NUM  / 1
4 : Directive -> . REVEAL  / 1
5 : Directive -> . REVEAL NUM  / 1
6 : Main -> . Directive EOF  / 0

STEP => shift 3
REVEAL => shift 2
STOP => shift 5
PREV => shift 4
Directive => goto 1
Main => goto 6

-----

State 1:

6 : Main -> Directive . EOF  / 0

EOF => shift 7

-----

State 2:

4 : Directive -> REVEAL .  / 1
5 : Directive -> REVEAL . NUM  / 1

NUM => shift 8
EOF => reduce 4

-----

State 3:

0 : Directive -> STEP .  / 1

EOF => reduce 0

-----

State 4:

2 : Directive -> PREV .  / 1
3 : Directive -> PREV . NUM  / 1

NUM => shift 9
EOF => reduce 2

-----

State 5:

1 : Directive -> STOP .  / 1

EOF => reduce 1

-----

State 6:

start -> Main .  / 0

$ => accept

-----

State 7:

6 : Main -> Directive EOF .  / 0

$ => reduce 6

-----

State 8:

5 : Directive -> REVEAL NUM .  / 1

EOF => reduce 5

-----

State 9:

3 : Directive -> PREV NUM .  / 1

EOF => reduce 3

-----

lookahead 0 = $ 
lookahead 1 = EOF 

*)

struct
local
structure Value = struct
datatype nonterminal =
nonterminal
| int of Arg.int
| symbol of Arg.symbol
| directive of Arg.directive
end
structure ParseEngine = ParseEngineFun (structure Streamable = Streamable
type terminal = Arg.terminal
type value = Value.nonterminal
val dummy = Value.nonterminal
fun read terminal =
(case terminal of
Arg.NUM x => (1, Value.int x)
| Arg.SYMBOL x => (2, Value.symbol x)
| Arg.STEP => (3, Value.nonterminal)
| Arg.REVEAL => (4, Value.nonterminal)
| Arg.STOP => (5, Value.nonterminal)
| Arg.EQUAL => (6, Value.nonterminal)
| Arg.SET => (7, Value.nonterminal)
| Arg.PREV => (8, Value.nonterminal)
| Arg.EOF => (9, Value.nonterminal)
)
)
in
val parse = ParseEngine.parse (
ParseEngine.next5x1 "\128\128\128\132\131\134\128\128\133\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\128\128\128\128\128\128\128z\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128~\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\138\128\128\128\128\128\128\128|\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128}\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\127\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128x\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128y\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128{\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128",
ParseEngine.next5x1 "\129\134\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128",
Vector.fromList [(0,1,(fn _::rest => Value.directive(Arg.step {})::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.stop {})::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.prev {})::rest|_=>raise (Fail "bad parser"))),
(0,2,(fn Value.int(arg0)::_::rest => Value.directive(Arg.num_prev arg0)::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.bare_reveal {})::rest|_=>raise (Fail "bad parser"))),
(0,2,(fn Value.int(arg0)::_::rest => Value.directive(Arg.num_reveal arg0)::rest|_=>raise (Fail "bad parser"))),
(1,2,(fn _::Value.directive(arg0)::rest => Value.directive(Arg.main arg0)::rest|_=>raise (Fail "bad parser")))],
(fn Value.directive x => x | _ => raise (Fail "bad parser")), Arg.error)
end
end
