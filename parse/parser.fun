(* File generated by CM-Yacc version 2.1 *)

functor ParserFun
   (structure Streamable : STREAMABLE
    structure Arg :
       sig
          type int
          type symbol
          type directive

          val main : directive -> directive
          val run : unit -> directive
          val break_fn : symbol -> directive
          val num_reveal : int -> directive
          val bare_reveal : unit -> directive
          val num_prev : int -> directive
          val prev : unit -> directive
          val stop : unit -> directive
          val step : unit -> directive

          datatype terminal =
             NUM of int
           | SYMBOL of symbol
           | STEP
           | REVEAL
           | STOP
           | EQUAL
           | SET
           | PREV
           | BREAK
           | RUN
           | EOF

          val error : terminal Streamable.t -> exn
       end)
   :>
   sig
      val parse : Arg.terminal Streamable.t -> Arg.directive * Arg.terminal Streamable.t
   end
=

(*

AUTOMATON LISTING
=================

State 0:

start -> . Main  / 0
0 : Directive -> . STEP  / 1
1 : Directive -> . STOP  / 1
2 : Directive -> . PREV  / 1
3 : Directive -> . PREV NUM  / 1
4 : Directive -> . REVEAL  / 1
5 : Directive -> . REVEAL NUM  / 1
6 : Directive -> . BREAK SYMBOL  / 1
7 : Directive -> . RUN  / 1
8 : Main -> . Directive EOF  / 0

STEP => shift 5
REVEAL => shift 4
STOP => shift 7
PREV => shift 6
BREAK => shift 3
RUN => shift 2
Directive => goto 1
Main => goto 8

-----

State 1:

8 : Main -> Directive . EOF  / 0

EOF => shift 9

-----

State 2:

7 : Directive -> RUN .  / 1

EOF => reduce 7

-----

State 3:

6 : Directive -> BREAK . SYMBOL  / 1

SYMBOL => shift 10

-----

State 4:

4 : Directive -> REVEAL .  / 1
5 : Directive -> REVEAL . NUM  / 1

NUM => shift 11
EOF => reduce 4

-----

State 5:

0 : Directive -> STEP .  / 1

EOF => reduce 0

-----

State 6:

2 : Directive -> PREV .  / 1
3 : Directive -> PREV . NUM  / 1

NUM => shift 12
EOF => reduce 2

-----

State 7:

1 : Directive -> STOP .  / 1

EOF => reduce 1

-----

State 8:

start -> Main .  / 0

$ => accept

-----

State 9:

8 : Main -> Directive EOF .  / 0

$ => reduce 8

-----

State 10:

6 : Directive -> BREAK SYMBOL .  / 1

EOF => reduce 6

-----

State 11:

5 : Directive -> REVEAL NUM .  / 1

EOF => reduce 5

-----

State 12:

3 : Directive -> PREV NUM .  / 1

EOF => reduce 3

-----

lookahead 0 = $ 
lookahead 1 = EOF 

*)

struct
local
structure Value = struct
datatype nonterminal =
nonterminal
| int of Arg.int
| symbol of Arg.symbol
| directive of Arg.directive
end
structure ParseEngine = ParseEngineFun (structure Streamable = Streamable
type terminal = Arg.terminal
type value = Value.nonterminal
val dummy = Value.nonterminal
fun read terminal =
(case terminal of
Arg.NUM x => (1, Value.int x)
| Arg.SYMBOL x => (2, Value.symbol x)
| Arg.STEP => (3, Value.nonterminal)
| Arg.REVEAL => (4, Value.nonterminal)
| Arg.STOP => (5, Value.nonterminal)
| Arg.EQUAL => (6, Value.nonterminal)
| Arg.SET => (7, Value.nonterminal)
| Arg.PREV => (8, Value.nonterminal)
| Arg.BREAK => (9, Value.nonterminal)
| Arg.RUN => (10, Value.nonterminal)
| Arg.EOF => (11, Value.nonterminal)
)
)
in
val parse = ParseEngine.parse (
ParseEngine.next5x1 "\128\128\128\134\133\136\128\128\135\132\131\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\138\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128w\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\139\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\140\128\128\128\128\128\128\128\128\128z\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128~\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\141\128\128\128\128\128\128\128\128\128|\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128}\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\127\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128v\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128x\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128y\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128{\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128",
ParseEngine.next5x1 "\129\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128",
Vector.fromList [(0,1,(fn _::rest => Value.directive(Arg.step {})::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.stop {})::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.prev {})::rest|_=>raise (Fail "bad parser"))),
(0,2,(fn Value.int(arg0)::_::rest => Value.directive(Arg.num_prev arg0)::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.bare_reveal {})::rest|_=>raise (Fail "bad parser"))),
(0,2,(fn Value.int(arg0)::_::rest => Value.directive(Arg.num_reveal arg0)::rest|_=>raise (Fail "bad parser"))),
(0,2,(fn Value.symbol(arg0)::_::rest => Value.directive(Arg.break_fn arg0)::rest|_=>raise (Fail "bad parser"))),
(0,1,(fn _::rest => Value.directive(Arg.run {})::rest|_=>raise (Fail "bad parser"))),
(1,2,(fn _::Value.directive(arg0)::rest => Value.directive(Arg.main arg0)::rest|_=>raise (Fail "bad parser")))],
(fn Value.directive x => x | _ => raise (Fail "bad parser")), Arg.error)
end
end
